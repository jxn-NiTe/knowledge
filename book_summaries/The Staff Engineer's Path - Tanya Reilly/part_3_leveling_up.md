# Leveling Up

## You're a Role Model Now (Sorry)

meaning of doing a good job

- the work you do is implicitly the type and standard of work that others will see as correct and emulate
- be mature, constructive and accountable
- being a role model doesn't necessarily mean being loud or a public figure
- you can lead being quiet and thoughtful, influencing through good decisions and collaboration
- leadership is a skill to build
- the below are 4 aspirational qualities to have
  - but have the good sense to know when conventional wisdom is wrong

be competent

- know things
  - have technical knowledge, which underpins the big-picture thinking, project execution and influence
  - have sufficient experience working through technical problems yourself before you go on the staff or manager track
  - build domain knowledge
    - your general experience helps to recognize problem shapes in new domains and pattern-match
    - the broader the scope of your experience the faster you can learn new things
  - have a growth mindset and keep learning
- be self-aware
  - admit what you know, being competent doesn't mean you need to be the best
  - admit what you don't know, so you don't make bad decisions and lose an opportunity to learn
  - understand topics in your own context well enough to be able to explain them simply to non-experts
- have high standards
  - seek out constructive criticism (ask for code or design reviews, peer evaluations, let someone poke holes in your idea)
  - mistakes will inevitably happen, so own them
    - set out to fix them and communicate clearly and quickly
    - consider having a retrospective
  - be reliable
    - finish what you start and become trusted to get things under control and done well

be responsible

- take ownership
  - own the whole problem, navigate problems and be accountable for the result
  - use your own good judgement, don't constantly ask for permission, but signal what you are going to do ('radiate intent')
  - this creates an opportunity to intervene but does not transfer blame if things go wrong
  - when a decision is needed: weigh the options, choose decisively, explain your reasoning
  - ask 'obvious' questions to make the implicit explicit
  - do glue work (unblocking, onboarding, mentoring, scheduling, ...) yourself and redirect juniors towards more technical tasks
- take charge
  - step up in an emergency, explicitly coordinate and set expectations, rather than adding noise
  - ask for more information when everyone is confused (which junior people might not do, being afraid to admit they don't know something)
  - drive meetings: make sure there is an agenda, take and distribute notes (allows to frame the decision)
  - when someone said something offensive in a public channel, speak up
- create calm
  - defuse problems, don't amplify them
  - avoid blame, create an environment where its safe talking through an event and learn something
  - be consistent and predictable to create a sense of safety (this requires working in a sustainable way yourself)

remember the goal

- remember there's a business
  - software is in service of business goals
  - adapt to the situation, businesses change and so will your responsibilities (growth, new markets, holiday seasons, ,,,)
  - be aware of the budget and spend resources mindfully
- remember there's a user
  - know who uses your software and how, don't imagine a set of fictional, perfect users
  - make sure they can use the software and want to by writing things down (be clear about requirements, get proposed API reviewed, discuss a UI mockup, check in frequently)
- remember there's a team
  - don't become a single point of failure jumping on all the problems (not sustainable)
  - be aware of the team's capabilities and reach goals by empowering others

look ahead

- 'software engineering is programming integrated over time', don't optimize for now at the cost of future velocity or engineering ability
- anticipate what you'll wish you had done
  - telegraph what's coming, e.g. announce intention to deprecate a system, so new projects will know not to invest in it
  - tidy up: leave environments, codebase or documentation so that it just works, follow style guide, leave no traps like dangerous script
  - keep tools sharp: look for optimizations that will let you build, deploy and release more quickly
  - write things down to create institutional memory (decision records, system diagrams, code comments that explain context), include searchable keywords
- expect failure
  - can't predict everything: network, hardware, people, bugs, interactions
  - but predict that something will go wrong and build expectation of failure into your products
  - test error-paths and make product do something sensible and user-friendly
  - make sure you will find out when the system misbehaves
  - think about incident command system, chaos engineering and drills
- optimize for maintenance, not creation
  - software is created once and needs to be maintained for years (monitoring, scaling, regulatory requirements, updated protocols, ...)
  - make it understandable by documentation and diagrams, make your system observable (tracing, easy to analyze and debug)
  - keep it simple: after initial solution see if you can make it simpler (fewer LOC, fewer branches, fewer hours of maintenance, fewer ...)
  - when dealing with inherently complex problems, make deliberate decision where in the system to put the complexity (business logic, optimization), so it can be treated as a black box and everything else is easy to reason about
  - build things modular with clean interfaces, to keep with evolving architecture
- create future leaders
  - junior engineers are future senior engineers
  - give them space to learn, opportunities to do hands-on work and solve increasingly difficult problems

'the metric for success is whether other people want to work with you'

## Good Influence at Scale

## What's Next?
